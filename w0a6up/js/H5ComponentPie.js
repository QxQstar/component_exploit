/* 饼图组件对象 */
function H5ComponentPie(name,cfg){
    var component = new H5ComponentBase(name,cfg);
    //背景层
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    var w = canvas.width = context.width = cfg.width;
    var h = canvas.height = context.height = cfg.height;
    var r = Math.min(w/2,h/2);
    component.append(canvas);
    context.beginPath();
    context.fillStyle = '#F5EDE3';
    context.arc(w/2,h/2,r,0,2*Math.PI);
    context.fill();
    //数据层
    canvas = document.createElement('canvas');
    context = canvas.getContext('2d');
    canvas.width = context.width = w;
    canvas.height = context.height = h;
    component.append(canvas);
    var data = cfg.data;
    var len = data.length;
    var endAngle,centre, x, y,startAngle = 1.5 * Math.PI;
    for(var i = 0; i<len ; i++){
        endAngle = startAngle + data[i][1]*(2*Math.PI);
        context.beginPath();
        context.fillStyle = data[i][2];
        context.moveTo(w/2,h/2);
        context.arc(w/2,h/2,r,startAngle,endAngle);
        centre = (startAngle + endAngle)/2;
        var div = $('<div class="text"></div>');
        div.text(data[i][0]).append($("<div>"+ data[i][1] +"</div>"));
        y = w/4 + w/4*Math.cos(0.5*Math.PI - centre);
        x = h/4 + w/4*Math.sin(0.5 * Math.PI - centre);
        div.css({opacity:0});
        if(y >= h/4){
            div.css({top:y + 5});
        }else{
            div.css({bottom:h/2 - y + 5});
        }
        if(x >= w/4){
            div.css({left:x + 5});
        }else{
            div.css({right:w/2 - x + 5});
        }
        component.append(div);

        context.closePath();
        context.fill();
        startAngle = endAngle;
    }
    //蒙版层，实现动画
    startAngle = 1.5 * Math.PI;
    canvas = document.createElement('canvas');
    context = canvas.getContext('2d');
    canvas.width = context.width = w;
    canvas.height = context.height = h;
    component.append(canvas);
    function draw(per) {
        context.clearRect(0,0,w,h);
        context.beginPath();
        context.fillStyle = '#F5EDE3';
        context.moveTo(w / 2, h / 2);
        if(per >= 1){
            component.find('.text').each(function(index,element){
                (function(index,ele){
                    setTimeout(function(){
                        $(ele).animate({opacity:'1'},400);
                    },index*100);
                })(index,element);
            });
        }
        if(per <= 0){
            context.arc(w/2,h/2,r,0,2*Math.PI);
            component.find('.text').each(function(index,element){
                (function(index,ele){
                    setTimeout(function(){
                        $(ele).animate({opacity:'0'},400);
                    },index*10);
                })(index,element);
            });
        }else{
            context.arc(w / 2, h / 2, r, startAngle, startAngle + (2 * Math.PI) * per, true);
        }
        context.fill();
    }
    draw(0);
    component.on('onLoad',function(){
        var per = 0;
        for(i = 0;i<100;i++) {
            setTimeout(function () {
                per = per + 0.01;
                draw(per);
            }, 10 * i + 400);
        }
    });
    component.on("onLeave",function(){
        var per = 1;
        for(i = 0;i<100;i++) {
            setTimeout(function () {
                per = per - 0.01;
                draw(per);
            }, 10 * i + 400);
        }
    });
    return component;
}









